require'Utilities'
require'CodeWriting'
local U = Utilities
local CW = CodeWriting

deprecatedNaughtyModule(...)

local tabs = function(number)
	local indent = ''
	number = number or 0
	for i = 1, number do
		indent = indent..'\t'
	end
	return indent
end

local more = function(output, numtabs, newString)
	if numtabs > 0 then
		output = output..tabs(1)..newString
	else
		output = output..newString
	end
end

function writeClassBasedOnNumberOfArguments(myFile, nargs)
	local output
	output = ''
	output = output..			'template<'..CW.templateArguments(0, nargs)..'>\n'
	output = output..			'class Transmitter'..nargs..' : public Transmitter\n'
	output = output..			'{\n'
	output = output..tabs(1)..		'typedef void StaticFunction'..nargs..'('..CW.templateArgumentsSignature(0, nargs)..');\n'
	output = output..tabs(1)..		'\n'
	output = output..tabs(0)..	'public:\n'
	output = output..tabs(1)..			'Transmitter'..nargs..'(void)\n'
	output = output..tabs(2)..				': m_receivers(NULL)\n'
	output = output..tabs(2)..				', m_transmissionFailSafe(NULL)\n'
	output = output..tabs(2)..				', m_transmissionIter(NULL)\n'
	output = output..tabs(2)..				', m_isRepeatTransmissionRequired(false)\n'
	output = output..tabs(2)..				', m_isTransmitting(false)\n'
	output = output..tabs(1)..			'{ /* empty */ }\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** creates a transmitter that is connected to all of the receivers in the source */\n'
	output = output..tabs(1)..			'Transmitter'..nargs..'(const Transmitter'..nargs..'& source)\n'
	output = output..tabs(2)..				': Transmitter(source)\n'
	output = output..tabs(2)..				', m_receivers(NULL)\n'
	output = output..tabs(2)..				', m_transmissionFailSafe(NULL)\n'
	output = output..tabs(2)..				', m_transmissionIter(NULL)\n'
	output = output..tabs(2)..				', m_isRepeatTransmissionRequired(false)\n'
	output = output..tabs(2)..				', m_isTransmitting(false)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'Connection* iter(source.m_receivers);\n'
	output = output..tabs(2)..				'Connection* previous(NULL);\n'
	output = output..tabs(2)..				'Connection** destinationIter = &m_receivers;\n'
	output = output..tabs(2)..				'while (iter)\n'
	output = output..tabs(2)..				'{\n'
	output = output..tabs(3)..					'*destinationIter = iter->clone();\n'
	output = output..tabs(3)..					'(*destinationIter)->onConnect(*this);\n'
	output = output..tabs(3)..					'previous = *destinationIter;\n'
	output = output..tabs(3)..					'destinationIter = &(previous->m_next);\n'
	output = output..tabs(3)..					'iter = iter->m_next;\n'
	output = output..tabs(2)..				'}\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** disconnects from any receivers */\n'
	output = output..tabs(1)..			'virtual ~Transmitter'..nargs..'(void)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'disconnectAll();\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** manually disconnect from all receivers, and clear the list */\n'
	output = output..tabs(1)..			'void ceaseTransmission(void)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'disconnectAll();\n'
	output = output..tabs(2)..				'm_receivers = NULL;\n'
	output = output..tabs(2)..				'm_transmissionFailSafe = NULL;\n'
	output = output..tabs(2)..				'm_transmissionIter = NULL;\n'
	output = output..tabs(2)..				'm_isRepeatTransmissionRequired = false;\n'
	output = output..tabs(2)..				'm_isTransmitting = false;\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Connect to a receiver via a non-const method. Asserts that the receiver is not already connected. */\n'
	output = output..tabs(1)..			'template<class RECEIVER>\n'
	output = output..tabs(1)..			'void connect(RECEIVER& receiver, void (RECEIVER::* function)('..CW.templateArgumentsSignature(0, nargs)..'))\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'assert(function);\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'assert(!isConnected(receiver));\n'
	output = output..tabs(2)..				'connectUnchecked(receiver, function);\n'
	output = output..tabs(1)..			'}\n'	
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Connect to a receiver via a const method. Asserts that the receiver is not already connected. */\n'
	output = output..tabs(1)..			'template<class RECEIVER>\n'
	output = output..tabs(1)..			'void connect(RECEIVER& receiver, void (RECEIVER::* function)('..CW.templateArgumentsSignature(0, nargs)..') const)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'assert(function);\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'assert(!isConnected(receiver));\n'
	output = output..tabs(2)..				'connectUnchecked(receiver, function);\n'
	output = output..tabs(1)..			'}\n'	
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Connect to a receiver static method. Asserts that the method is not already connected. */\n'
	output = output..tabs(1)..			'void connect(StaticFunction'..nargs..'& function)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'assert(!isConnected(function));\n'
	output = output..tabs(2)..				'connectUnchecked(function);\n'
	output = output..tabs(1)..			'}\n'	
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Connect to a receiver via a non-const method.  Beware that the receiver might already be connected.  */\n'
	output = output..tabs(1)..			'template<class RECEIVER>\n'
	output = output..tabs(1)..			'void connectUnchecked(RECEIVER& receiver, void (RECEIVER::* function)('..CW.templateArgumentsSignature(0, nargs)..'))\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'assert(function);\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'Connection* connection(new volatile'..nargs..'<RECEIVER>(receiver, function));\n'
	output = output..tabs(2)..				'connection->m_next = m_receivers;\n'
	output = output..tabs(2)..				'm_receivers = connection;\n'
	output = output..tabs(2)..				'receiver.onConnect(*this);\n'
	output = output..tabs(1)..			'}\n'	
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Connect to a receiver via a const method.  Beware that the receiver might already be connected. */\n'
	output = output..tabs(1)..			'template<class RECEIVER>\n'
	output = output..tabs(1)..			'void connectUnchecked(RECEIVER& receiver, void (RECEIVER::* function)('..CW.templateArgumentsSignature(0, nargs)..') const)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'assert(function);\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'Connection* connection(new const'..nargs..'<RECEIVER>(receiver, function));\n'
	output = output..tabs(2)..				'connection->m_next = m_receivers;\n'
	output = output..tabs(2)..				'm_receivers = connection;\n'
	output = output..tabs(2)..				'receiver.onConnect(*this);\n'
	output = output..tabs(1)..			'}\n'	
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Connect to a receiver static method.  Beware that the function might already be connected. */\n'
	output = output..tabs(1)..			'void connectUnchecked(StaticFunction'..nargs..'& function)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'Connection* connection(new static'..nargs..'(function));\n'
	output = output..tabs(2)..				'connection->m_next = m_receivers;\n'
	output = output..tabs(2)..				'm_receivers = connection;\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Disconnects the receiver, assumes only one is connected */\n'
	output = output..tabs(1)..			'void disconnect(Receiver& receiver)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'disconnect(&receiver, NULL);\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Disconnects the function, assumes only one is connected */\n'
	output = output..tabs(1)..			'void disconnect(StaticFunction'..nargs..'& function)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'disconnect(NULL, &function);\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Returns true iff the receiver is currently connected to this transmitter. */\n'
	output = output..tabs(1)..			'template<class RECEIVER>\n'
	output = output..tabs(1)..			'bool isConnected(RECEIVER& receiver) const\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'return isConnected<RECEIVER>(receiver, IsReceiver<RECEIVER>());\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Returns true iff the function is currently connected to this transmitter. */\n'
	output = output..tabs(1)..			'bool isConnected(StaticFunction'..nargs..'& function) const\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'return isConnected<StaticFunction'..nargs..'>(function, IsFunction());\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Calls each method registered by all receivers. */\n'
	output = output..tabs(1)..			'void transmit('..CW.templateDeclareFunctionSignature(0, nargs)..')\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'if (m_isTransmitting)\n'
	output = output..tabs(2)..				'{\n'
	output = output..tabs(3)..					'm_isRepeatTransmissionRequired = true;\n'
	output = output..tabs(2)..				'}\n'
	output = output..tabs(2)..				'else\n'
	output = output..tabs(2)..				'{\n'
	output = output..tabs(3)..					'm_isTransmitting = true;\n'
	output = output..tabs(3)..					'm_transmissionIter = m_receivers;\n'
	output = output..tabs(3)..					'm_transmissionFailSafe = NULL;\n'
	output = output..tabs(3)..					'// the receiver list can be modified transmission\n'
	output = output..tabs(3)..					'while (m_transmissionIter)\n'
	output = output..tabs(3)..					'{\n'
	output = output..tabs(4)..						'm_transmissionIter->transmit('..CW.templateFunctionCallArguments(0, nargs)..');\n'
	output = output..tabs(4)..						'// calling transmit() might have triggered the removal of the receiver\n'
	output = output..tabs(4)..						'if (m_transmissionIter)\n'
	output = output..tabs(5)..							'm_transmissionIter = m_transmissionIter->m_next;\n'
	output = output..tabs(4)..						'else\n'
	output = output..tabs(5)..							'm_transmissionIter = m_transmissionFailSafe;\n'
	output = output..tabs(3)..					'}\n'
	output = output..tabs(3)..					'\n'
	output = output..tabs(3)..					'm_isTransmitting = false;\n'
	output = output..tabs(3)..					'\n'
	output = output..tabs(3)..					'if (m_isRepeatTransmissionRequired)\n'
	output = output..tabs(3)..					'{\n'
	output = output..tabs(4)..						'm_isRepeatTransmissionRequired = false;\n'
	output = output..tabs(4)..						'transmit('..CW.templateFunctionCallArguments(0, nargs)..');\n'
	output = output..tabs(3)..					'}\n'
	output = output..tabs(2)..				'}\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** Calls each method registered by all receivers. */\n'
	output = output..tabs(1)..			'inline void operator()('..CW.templateDeclareFunctionSignature(0, nargs)..')\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'transmit('..CW.templateFunctionCallArguments(0, nargs)..');\n'
	output = output..tabs(1)..			'}\n'		
	output = output..tabs(1)..			'\n'
	output = output..tabs(0)..		'protected:\n'
	output = output..tabs(1)..		'/** abstraction for all of the receivers that have registered with this transmitter */'
	output = output..tabs(1)..		'class Connection\n'
	output = output..tabs(1)..		'{\n'	
	output = output..tabs(1)..		'public:\n'
	output = output..tabs(2)..			'Connection(void) : m_next(NULL) { /* empty */ }\n'
	output = output..tabs(2)..			'virtual ~Connection(void)=0 { /* empty */ }\n'
	output = output..tabs(2)..			'virtual Connection* clone(void)=0;\n'
	output = output..tabs(2)..			'virtual Connection* duplicate(Receiver& receiver)=0;\n'
	output = output..tabs(2)..			'virtual bool isFunction(StaticFunction'..nargs..'&) const=0;\n'
	output = output..tabs(2)..			'virtual bool isReceiver(const Receiver&) const=0;\n'
	output = output..tabs(2)..			'virtual void onConnect(Transmitter&)=0;\n'
	output = output..tabs(2)..			'virtual void onDisconnect(Transmitter&)=0;\n'
	output = output..tabs(2)..			'virtual void transmit('..CW.templateArgumentsSignature(0, nargs)..')=0;\n'
	output = output..tabs(2)..			'Connection* m_next;\n'
	output = output..tabs(2)..			'private:\n'
	output = output..tabs(3)..				'Connection& operator=(const Connection&);\n'	
	output = output..tabs(1)..		'}; // class Connection\n'
	output = output..tabs(1)..		'\n'
	output = output..tabs(1)..		'/** template abstraction for receivers that registered non-const member functions with this transmitter */\n'
	output = output..tabs(1)..		'template< class RECEIVER >\n'
	output = output..tabs(1)..		'class volatile'..nargs..'\n'
	output = output..tabs(1)..		': public Connection\n'
	output = output..tabs(1)..		'{\n'
	output = output..tabs(1)..		'public:\n'
	output = output..tabs(2)..			'volatile'..nargs..'(RECEIVER& object, void (RECEIVER::* function)('..CW.templateArgumentsSignature(0, nargs)..'))\n'
	output = output..tabs(2)..			': m_object(object)\n'
	output = output..tabs(2)..			', m_function(function)\n'
	output = output..tabs(2)..			'{ /* empty */ }\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual Connection* clone(void)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return new volatile'..nargs..'<RECEIVER>(m_object, m_function);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual Connection* duplicate(Receiver& receiver)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return new volatile'..nargs..'<RECEIVER>(static_cast<RECEIVER&>(receiver), m_function);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual bool isFunction(StaticFunction'..nargs..'&) const\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return false;\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual bool isReceiver(const Receiver& receiver) const\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return &m_object == &static_cast<const RECEIVER&>(receiver);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual void onConnect(Transmitter& transmitter)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'm_object.onConnect(transmitter);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual void onDisconnect(Transmitter& transmitter)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'm_object.onDisconnect(transmitter);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual void transmit('..CW.templateDeclareFunctionSignature(0, nargs)..')\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'(m_object.*m_function)('..CW.templateFunctionCallArguments(0, nargs)..');\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(1)..		'private:\n'
	output = output..tabs(2)..			'RECEIVER& m_object;\n'
	output = output..tabs(2)..			'void (RECEIVER::* m_function)('..CW.templateArgumentsSignature(0, nargs)..');\n'
	output = output..tabs(1)..		'}; // class volatile'..nargs..'\n'
	output = output..tabs(1)..		'\n'
	output = output..tabs(1)..		'/** template abstraction for receivers that registered const member functions with this transmitter */\n'
	output = output..tabs(1)..		'template<class RECEIVER >\n'
	output = output..tabs(1)..		'class const'..nargs..'\n'
	output = output..tabs(1)..		': public Connection\n'
	output = output..tabs(1)..		'{\n'
	output = output..tabs(1)..		'public:\n'
	output = output..tabs(2)..			'const'..nargs..'(RECEIVER& object, void (RECEIVER::* function)('..CW.templateArgumentsSignature(0, nargs)..') const)\n'
	output = output..tabs(2)..			': m_object(object)\n'
	output = output..tabs(2)..			', m_function(function)\n'
	output = output..tabs(2)..			'{ /* empty */ }\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual Connection* clone(void)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return new const'..nargs..'<RECEIVER>(m_object, m_function);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual Connection* duplicate(Receiver& receiver)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return new const'..nargs..'<RECEIVER>(static_cast<RECEIVER&>(receiver), m_function);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual bool isFunction(StaticFunction'..nargs..'&) const\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return false;\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual bool isReceiver(const Receiver& receiver) const\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return &m_object == &static_cast<const RECEIVER&>(receiver);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual void onConnect(Transmitter& transmitter)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'm_object.onConnect(transmitter);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual void onDisconnect(Transmitter& transmitter)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'm_object.onDisconnect(transmitter);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual void transmit('..CW.templateDeclareFunctionSignature(0,nargs)..')\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'(m_object.*m_function)('..CW.templateFunctionCallArguments(0, nargs)..');\n'
	output = output..tabs(2)..			'}\n'	
	output = output..tabs(2)..			'\n'
	output = output..tabs(1)..		'private:\n'
	output = output..tabs(2)..			'RECEIVER& m_object;\n'
	output = output..tabs(2)..			'void (RECEIVER::* m_function)('..CW.templateArgumentsSignature(0, nargs)..') const;\n'
	output = output..tabs(1)..		'}; // class const'..nargs..'\n'
	output = output..tabs(1)..		'\n'
	output = output..tabs(1)..		'/** abstraction for static methods that registered this transmitter */\n'
	output = output..tabs(1)..		'class static'..nargs..'\n'
	output = output..tabs(1)..		': public Connection\n'
	output = output..tabs(1)..		'{\n'
	output = output..tabs(1)..		'public:\n'
	output = output..tabs(2)..			'static'..nargs..'(StaticFunction'..nargs..'& function)\n'
	output = output..tabs(2)..			': m_function(function)\n'
	output = output..tabs(2)..			'{ /* empty */ }\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual Connection* clone(void)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return new static'..nargs..'(m_function);\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual Connection* duplicate(Receiver&)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return clone();\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual bool isFunction(StaticFunction'..nargs..'& function) const\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return m_function == function;\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual bool isReceiver(const Receiver&) const\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'return false;\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual void onConnect(Transmitter&)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'/* empty */\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual void onDisconnect(Transmitter&)\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'/* empty */\n'
	output = output..tabs(2)..			'}\n'
	output = output..tabs(2)..			'\n'
	output = output..tabs(2)..			'virtual void transmit('..CW.templateDeclareFunctionSignature(0,nargs)..')\n'
	output = output..tabs(2)..			'{\n'
	output = output..tabs(3)..				'm_function('..CW.templateFunctionCallArguments(0, nargs)..');\n'
	output = output..tabs(2)..			'}\n'	
	output = output..tabs(2)..			'\n'
	output = output..tabs(1)..		'private:\n'
	output = output..tabs(2)..			'StaticFunction'..nargs..'& m_function;\n'
	output = output..tabs(1)..		'}; // class static'..nargs..'\n'
	output = output..tabs(1)..		'\n'
	output = output..tabs(1)..		'/** functor that helps clean up some internal code */\n'
	output = output..tabs(1)..		'struct IsFunction\n'
	output = output..tabs(1)..		'{\n'
	output = output..tabs(2)..			'inline bool operator()(const Connection& connection, StaticFunction'..nargs..'& function) const\n'	
	output = output..tabs(2)..			'{\n'	
	output = output..tabs(3)..				'return connection.isFunction(function);\n'
	output = output..tabs(2)..			'}\n'	
	output = output..tabs(1)..		'};\n'
	output = output..tabs(1)..		'\n'
	output = output..tabs(1)..		'/** functor that helps clean up some internal code */\n'
	output = output..tabs(1)..		'template<class RECEIVER>\n'
	output = output..tabs(1)..		'struct IsReceiver \n'
	output = output..tabs(1)..		'{\n'
	output = output..tabs(2)..			'inline bool operator()(const Connection& connection, RECEIVER& receiver) const\n'	
	output = output..tabs(2)..			'{\n'	
	output = output..tabs(3)..				'return connection.isReceiver(receiver);\n'
	output = output..tabs(2)..			'}\n'	
	output = output..tabs(1)..		'};\n'
	output = output..tabs(1)..			'/** disconnects a receiver, with it is an object or a static method */\n'
	output = output..tabs(1)..			'void disconnect(Receiver* receiver, StaticFunction'..nargs..'* function)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..					'SYNC(m_mutex);\n'
	output = output..tabs(2)..					'Connection* iter(m_receivers);\n'
	output = output..tabs(2)..					'Connection* previous(NULL);\n'
	output = output..tabs(2)..					'bool isFound(false);\n'
	output = output..tabs(2)..					'\n'
	output = output..tabs(2)..					'if (receiver)\n'
	output = output..tabs(2)..					'{\n'
	output = output..tabs(3)..						'while (iter)\n'
	output = output..tabs(3)..						'{\n'
	output = output..tabs(4)..							'if (iter->isReceiver(*receiver))\n'
	output = output..tabs(4)..							'{\n'
	output = output..tabs(5)..								'receiver->onDisconnect(*this);\n'
	output = output..tabs(5)..								'isFound = true;	\n'
	output = output..tabs(5)..								'break;\n'
	output = output..tabs(4)..							'}\n'
	output = output..tabs(4)..							'\n'
	output = output..tabs(4)..							'previous = iter;\n'
	output = output..tabs(4)..							'iter = iter->m_next;\n'
	output = output..tabs(3)..						'}\n'
	output = output..tabs(2)..					'}\n'
	output = output..tabs(2)..					'else\n'
	output = output..tabs(2)..					'{\n'
	output = output..tabs(3)..						'assert(function);\n'
	output = output..tabs(3)..						'while (iter)\n'
	output = output..tabs(3)..						'{\n'
	output = output..tabs(4)..							'if (iter->isFunction(*function))\n'
	output = output..tabs(4)..							'{\n'
	output = output..tabs(5)..								'isFound = true;	\n'
	output = output..tabs(5)..								'break;\n'
	output = output..tabs(4)..							'}\n'
	output = output..tabs(4)..							'\n'
	output = output..tabs(4)..							'previous = iter;\n'
	output = output..tabs(4)..							'iter = iter->m_next;\n'
	output = output..tabs(3)..						'}\n'
	output = output..tabs(2)..					'}\n'
	output = output..tabs(2)..					'\n'
	output = output..tabs(2)..					'if (isFound)\n'
	output = output..tabs(2)..					'{	\n'
	output = output..tabs(3)..						'if (previous)\n'
	output = output..tabs(3)..						'{	// eliminate the position in the list\n'
	output = output..tabs(4)..							'previous->m_next = iter->m_next;\n'
	output = output..tabs(3)..						'}\n'
	output = output..tabs(3)..						'else \n'
	output = output..tabs(3)..						'{	// the first list element was removed, set the head to removed->next\n'
	output = output..tabs(4)..							'm_receivers = iter->m_next;\n'
	output = output..tabs(3)..						'}\n'
	output = output..tabs(3)..						'\n'
	output = output..tabs(3)..						'// if transmitting...	\n'
	output = output..tabs(3)..						'if (m_isTransmitting)\n'
	output = output..tabs(3)..						'{	// ...and we just removed the transmission iter...\n'
	output = output..tabs(4)..							'if (m_transmissionIter == iter)\n'
	output = output..tabs(4)..							'{	// ...preserve integrity of the transmission\n'
	output = output..tabs(5)..								'm_transmissionFailSafe = iter->m_next;\n'
	output = output..tabs(5)..								'm_transmissionIter = NULL;\n'
	output = output..tabs(4)..							'}\n'
	output = output..tabs(4)..							'// ...else if we removed the fail safe during a transmission...\n'
	output = output..tabs(4)..							'else if (m_transmissionFailSafe == iter)\n'
	output = output..tabs(4)..							'{	// ...preserve integrity of the transmission\n'
	output = output..tabs(5)..								'm_transmissionFailSafe = m_transmissionFailSafe->m_next;\n'
	output = output..tabs(5)..								'm_transmissionIter = NULL;\n'
	output = output..tabs(4)..							'}\n'
	output = output..tabs(3)..						'}\n'
	output = output..tabs(3)..						'\n'
	output = output..tabs(3)..						'delete iter;\n'
	output = output..tabs(2)..					'}\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** disconnects all receivers, but doesn\'t empty the list */\n'
	output = output..tabs(1)..			'void disconnectAll(void)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'Connection* iter(m_receivers);\n'
	output = output..tabs(2)..				'\n'
	output = output..tabs(2)..				'while (iter)\n'
	output = output..tabs(2)..				'{\n'
	output = output..tabs(3)..					'iter->onDisconnect(*this);\n'
	output = output..tabs(3)..					'Connection* stale(iter);\n'
	output = output..tabs(3)..					'iter = iter->m_next;\n'
	output = output..tabs(3)..					'delete stale;\n'
	output = output..tabs(2)..				'}\n'
	output = output..tabs(2)..				'\n'
	output = output..tabs(2)..				'm_receivers = NULL;\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** returns true iff the receiver (object or static method) is connected to this transmitter */\n'
	output = output..tabs(1)..			'template <typename RECEIVER, typename IS_EQUAL>\n'
	output = output..tabs(1)..			'bool isConnected(RECEIVER& receiver, const IS_EQUAL& isEqual) const\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'Connection* iter(m_receivers);\n'
	output = output..tabs(2)..				'\n'
	output = output..tabs(2)..				'while (iter)\n'
	output = output..tabs(2)..				'{\n'
	output = output..tabs(3)..					'if (isEqual(*iter, receiver))\n'
	output = output..tabs(3)..					'{\n'
	output = output..tabs(4)..						'return true;\n'
	output = output..tabs(3)..					'}\n'
	output = output..tabs(3)..					'\n'
	output = output..tabs(3)..					'iter = iter->m_next;\n'
	output = output..tabs(2)..				'}\n'
	output = output..tabs(2)..				'\n'
	output = output..tabs(2)..				'return false;\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** called by the be receivers that are disconnecting of their own accord */\n'
	output = output..tabs(1)..			'void onDisconnect(Receiver& receiver)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'Connection* iter(m_receivers);\n'
	output = output..tabs(2)..				'Connection* previous(NULL);\n'
	output = output..tabs(2)..				'\n'
	output = output..tabs(2)..				'while (iter)\n'
	output = output..tabs(2)..				'{\n'
	output = output..tabs(3)..					'if (iter->isReceiver(receiver))\n'
	output = output..tabs(3)..					'{\n'
	output = output..tabs(4)..						'if (previous)\n'
	output = output..tabs(4)..						'{\n'
	output = output..tabs(5)..							'previous->m_next = iter->m_next;\n'
	output = output..tabs(4)..						'}\n'
	output = output..tabs(4)..						'else\n'
	output = output..tabs(4)..						'{\n'
	output = output..tabs(5)..							'm_receivers = iter->m_next;\n'
	output = output..tabs(4)..						'}\n'
	output = output..tabs(4)..						'\n'
	output = output..tabs(4)..						'delete iter;\n'
	output = output..tabs(4)..						'break;\n'
	output = output..tabs(3)..					'}\n'
	output = output..tabs(3)..					'\n'
	output = output..tabs(3)..					'previous = iter;\n'
	output = output..tabs(3)..					'iter = iter->m_next;\n'
	output = output..tabs(2)..				'}\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(1)..			'\n'
	output = output..tabs(1)..			'/** helps with copy constructors of receivers */\n'
	output = output..tabs(1)..			'void replicate(const Receiver& receiver, Receiver& new_receiver)\n'
	output = output..tabs(1)..			'{\n'
	output = output..tabs(2)..				'SYNC(m_mutex);\n'
	output = output..tabs(2)..				'Connection* iter(m_receivers);\n'
	output = output..tabs(2)..				'\n'
	output = output..tabs(2)..				'while (iter)\n'
	output = output..tabs(2)..				'{\n'
	output = output..tabs(3)..					'if (iter->isReceiver(receiver))\n'
	output = output..tabs(3)..					'{\n'
	output = output..tabs(4)..						'Connection* connection = iter->duplicate(new_receiver);\n'
	output = output..tabs(4)..						'connection->m_next = m_receivers;\n'
	output = output..tabs(4)..						'm_receivers = connection;\n'
	output = output..tabs(4)..						'break;\n'
	output = output..tabs(3)..					'}\n'
	output = output..tabs(2)..				'}\n'
	output = output..tabs(1)..			'}\n'
	output = output..tabs(0)..			'private:\n'
	output = output..tabs(1)..				'DECLARE_MUTABLE_MUTEX(m_mutex);\n'
	output = output..tabs(1)..				'Connection* m_receivers;\n'
	output = output..tabs(1)..				'Connection* m_transmissionIter;\n'
	output = output..tabs(1)..				'Connection* m_transmissionFailSafe;\n'
	output = output..tabs(1)..				'bool m_isRepeatTransmissionRequired;\n'
	output = output..tabs(1)..				'bool m_isTransmitting;\n'
	output = output..tabs(0)..			'}; // class Transmitter'..nargs
	myFile:write(output)
end

function writeFileEnd(myFile)
	myFile:write('} // namespace signals\n#endif//SIGNALS_H')
end

function writeToFile(myFile, nargs)
	for i=1,nargs do
		writeClassBasedOnNumberOfArguments(myFile, i)
		myFile:write('\n\n')
	end
	writeFileEnd(myFile)	
	myFile:flush()
end